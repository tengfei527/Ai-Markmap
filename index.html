<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>AI思维导图生成 - AiMarkmap</title>
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%23667eea'/%3E%3Cg stroke='white' stroke-width='6' stroke-linecap='round'%3E%3Cline x1='50' y1='50' x2='80' y2='25'/%3E%3Cline x1='50' y1='50' x2='25' y2='40'/%3E%3Cline x1='50' y1='50' x2='60' y2='80'/%3E%3C/g%3E%3Ccircle cx='50' cy='50' r='12' fill='white'/%3E%3Ccircle cx='80' cy='25' r='8' fill='white'/%3E%3Ccircle cx='25' cy='40' r='8' fill='white'/%3E%3Ccircle cx='60' cy='80' r='8' fill='white'/%3E%3Cpath d='M50 44L52 48 L56 50 L52 52 L50 56 L48 52 L44 50 L48 48 Z' fill='%23764ba2'/%3E%3C/svg%3E">
<script src="https://unpkg.com/d3@7.8.5/dist/d3.min.js"></script>
<script src="https://unpkg.com/markmap-lib@0.15.3/dist/browser/index.js"></script>
<script src="https://unpkg.com/markmap-view@0.15.3/dist/browser/index.js"></script>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; } body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; } 
    .header { background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); padding: 0.5rem 2rem; border-bottom: 1px solid rgba(255, 255, 255, 0.2); display: flex; align-items: center; justify-content: space-between; } 
    .header h1 { color: white; font-size: 1.8rem; font-weight: 600; display: flex; align-items: center; gap: 0.5rem; } .ai-badge { background: linear-gradient(45deg, #ff6b6b, #ffa500); padding: 0.3rem 0.8rem; border-radius: 20px; font-size: 0.8rem; font-weight: 500; color: white; animation: pulse 2s infinite; } @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } } 
    .header-right { display: flex; align-items: center; gap: 1rem; }
    .github-link { display: flex; align-items: center; color: white; transition: opacity 0.2s; }
    .github-link:hover { opacity: 0.8; }
    .github-icon { width: 28px; height: 28px; }
    .lang-switcher { display: flex; align-items: center; gap: 0.5rem; }
    .lang-btn { background: rgba(255, 255, 255, 0.2); border: 1px solid rgba(255, 255, 255, 0.3); color: white; padding: 0.4rem 0.8rem; border-radius: 6px; cursor: pointer; font-size: 0.85rem; font-weight: 500; transition: all 0.2s; }
    .lang-btn:hover { background: rgba(255, 255, 255, 0.4); }
    .lang-btn.active { background: white; color: #667eea; font-weight: 600; border-color: white; }
    .container { display: flex; height: calc(100vh - 68px); gap: 1rem; padding: 1rem; flex-wrap: nowrap; } 
    .editor-panel { width: 400px; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); border-radius: 12px; display: flex; flex-direction: column; overflow: hidden; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1); flex-shrink: 0; height: 100%; } .panel-header { background: rgba(102, 126, 234, 0.1); padding: 0.5rem 1rem; border-bottom: 1px solid rgba(102, 126, 234, 0.2); flex-shrink: 0; } .panel-title { font-size: 1rem; font-weight: 600; color: #4c63d2; margin-bottom: 0.25rem; display: flex; align-items: center; gap: 0.5rem; } .ai-config { background: rgba(255, 255, 255, 0.8); padding: 0.75rem; border-bottom: 1px solid #e0e0e0; flex-shrink: 0; } .config-row { display: flex; gap: 0.5rem; margin-bottom: 0.4rem; align-items: center; } .config-label { font-size: 0.8rem; color: #666; min-width: 50px; flex-shrink: 0; padding-top: 0; } .config-input { flex: 1; padding: 0.4rem 0.6rem; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85rem; min-width: 120px; height: 32px; } .model-input-wrapper { flex: 1; display: flex; flex-direction: column; } .hidden { display: none !important; } #custom-model-input { margin-top: 0.4rem; } .model-container {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.3rem;
  width: 100%;
  overflow: hidden; display: flex; gap: 0.3rem; align-items: center; width: 100%; } .model-select {
  flex: 1 1 auto;
  width: 240px; max-width: 100%;
  min-width: 0;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
  min-width: 0;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden; flex: 1; padding: 0.4rem 0.6rem; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85rem; height: 32px; background: white; cursor: pointer; } .query-models-btn {
  flex-shrink: 0;
  flex-grow: 0;
  flex-basis: 60px;
  max-width: 80px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  min-width: 60px;
  max-width: 80px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis; padding: 0.3rem 0.6rem; border: 1px solid #667eea; border-radius: 4px; background: linear-gradient(135deg, #e3f2fd, #f3e5f5); color: #4c63d2; cursor: pointer; font-size: 0.75rem; transition: all 0.2s; white-space: nowrap; height: 32px; display: flex; align-items: center; justify-content: center; min-width: 60px; } .query-models-btn:hover { background: linear-gradient(135deg, #bbdefb, #e1bee7); transform: translateY(-1px); box-shadow: 0 3px 8px rgba(102, 126, 234, 0.2); } .query-models-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; box-shadow: none !important; } .button-row { display: flex; gap: 0.4rem; margin-bottom: 0.6rem; } .control-btn { padding: 0.5rem 0.8rem; border: none; border-radius: 5px; cursor: pointer; font-size: 0.85rem; transition: all 0.2s; flex: 1; min-width: 70px; font-weight: 500; height: 34px; display: flex; align-items: center; justify-content: center; } .control-btn.ai-btn { background: linear-gradient(45deg, #667eea, #764ba2); color: white; border: 2px solid transparent; } .control-btn.ai-btn:hover { background: linear-gradient(45deg, #5a67d8, #6b46c1); transform: translateY(-1px); box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3); } .control-btn.view-btn { background: linear-gradient(135deg, #e3f2fd, #f3e5f5); color: #4c63d2; border: 1px solid #667eea; } .control-btn.view-btn:hover { background: linear-gradient(135deg, #bbdefb, #e1bee7); transform: translateY(-1px); box-shadow: 0 3px 8px rgba(102, 126, 234, 0.2); } .control-btn.view-btn.active { background: linear-gradient(45deg, #667eea, #764ba2); color: white; border: 1px solid #667eea; box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4); } .control-btn.markdown-btn { background: linear-gradient(135deg, #e8f5e8, #f0f8ff); color: #2e7d32; border: 1px solid #4caf50; } .control-btn.markdown-btn:hover { background: linear-gradient(135deg, #c8e6c9, #e3f2fd); transform: translateY(-1px); box-shadow: 0 3px 8px rgba(76, 175, 80, 0.2); } .control-btn.markdown-btn.active { background: linear-gradient(45deg, #4caf50, #2e7d32); color: white; border: 1px solid #4caf50; box-shadow: 0 2px 8px rgba(76, 175, 80, 0.4); } .control-btn.clear-btn { background: linear-gradient(135deg, #ffebee, #fce4ec); color: #d32f2f; border: 1px solid #f44336; flex: 0 0 auto; min-width: 55px; } .control-btn.clear-btn:hover { background: linear-gradient(135deg, #ffcdd2, #f8bbd9); transform: translateY(-1px); box-shadow: 0 3px 8px rgba(244, 67, 54, 0.2); } .control-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; box-shadow: none !important; } .input-section { flex: 1; display: flex; flex-direction: column; padding: 0.75rem; overflow: hidden; } .text-input, .content-display { width: 100%; flex: 1; padding: 0.75rem; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9rem; resize: none; line-height: 1.5; background: #fafafa; min-height: 200px; } .mindmap-panel { flex: 1; background: white; border-radius: 12px; overflow: hidden; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1); position: relative; display: flex; flex-direction: column; height: 100%; } 
    .mindmap-header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 0.5rem 1rem; display: flex; justify-content: space-between; align-items: center; gap: 0.5rem; } .export-btn { background: rgba(255, 255, 255, 0.2); color: white; border: 1px solid rgba(255, 255, 255, 0.3); padding: 0.4rem 1rem; border-radius: 6px; cursor: pointer; transition: all 0.2s; min-width: 80px; font-weight: 500; } .export-btn:hover { background: rgba(255, 255, 255, 0.3); transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); } .export-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; box-shadow: none !important; } 
    .results-tabs { display: flex; gap: 0.5rem; }
    .result-tab-btn { background: rgba(255, 255, 255, 0.2); color: white; border: 1px solid rgba(255, 255, 255, 0.3); padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; transition: all 0.2s; font-weight: 500; }
    .result-tab-btn:hover { background: rgba(255, 255, 255, 0.3); }
    .result-tab-btn.active { background: rgba(255, 255, 255, 0.4); font-weight: 700; border-color: white; }
    .mindmap-container { width: 100%; height: calc(100% - 52px); background: white; position: relative; flex: 1; } #mindmap { width: 100%; height: 100%; }
    .loading-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255, 255, 255, 0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; color: #666; gap: 0.5rem; }
    .spinner-container { position: relative; width: 60px; height: 60px; margin-bottom: 0.5rem; }
    .loading-spinner { width: 60px; height: 60px; border: 5px solid #f3f3f3; border-top: 5px solid #4c63d2; border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    #timer-display { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-weight: 600; color: #5a67d8; font-size: 1rem; }
    .status-message { font-size: 0.9rem; text-align: center; }

    .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); display: flex; align-items: center; justify-content: center; z-index: 2000; backdrop-filter: blur(5px); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
    .modal-overlay:not(.hidden) { opacity: 1; visibility: visible; }
    .modal-content { background: #fdfdff; border-radius: 12px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2); width: 450px; overflow: hidden; position: relative; transform: scale(0.95); transition: transform 0.3s ease; }
    .modal-overlay:not(.hidden) .modal-content { transform: scale(1); }
    .modal-close-btn { position: absolute; top: 10px; right: 15px; background: none; border: none; font-size: 1.8rem; color: #999; cursor: pointer; line-height: 1; padding: 0; }
    .modal-close-btn:hover { color: #333; }
    .modal-content .ai-config { padding: 1rem 1.5rem 1.5rem 1.5rem; background: transparent; border-bottom: none; }
    .modal-content .panel-header { background: rgba(102, 126, 234, 0.1); padding: 1rem 1.5rem; }
    .panel-section { padding: 0.75rem; background: rgba(255, 255, 255, 0.8); border-bottom: 1px solid #e0e0e0; }
    .panel-section .config-row { margin-bottom: 0 !important; }
    .panel-section .button-row:last-child { margin-bottom: 0; }
    .editor-panel > .panel-header { display: flex; justify-content: space-between; align-items: center; }
    
    #settings-btn, #prompt-settings-btn {
        flex: 0 0 auto;
        padding: 0.4rem 0.8rem;
        height: 30px;
        background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
        color: #4c63d2;
        border: 1px solid #667eea;
    }
    #settings-btn:hover, #prompt-settings-btn:hover {
        background: linear-gradient(135deg, #bbdefb, #e1bee7);
        transform: translateY(-1px);
        box-shadow: 0 3px 8px rgba(102, 126, 234, 0.2);
    }
    
    .prompt-tip {
        background-color: #e3f2fd;
        border: 1px solid #90caf9;
        color: #1e88e5;
        padding: 0.75rem 1rem;
        border-radius: 6px;
        font-size: 0.85rem;
        margin-bottom: 1rem;
        line-height: 1.4;
    }
    .prompt-tip code {
        background-color: rgba(255, 255, 255, 0.7);
        padding: 0.1em 0.4em;
        border-radius: 4px;
        font-weight: 600;
        color: #d32f2f;
    }
    
    #version-slider {
        flex: 1;
        -webkit-appearance: none;
        appearance: none;
        height: 8px;
        background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
        border-radius: 5px;
        outline: none;
        cursor: pointer;
        border: 1px solid rgba(102, 126, 234, 0.2);
        transition: opacity .2s;
    }

    #version-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        background: #fff;
        border-radius: 50%;
        cursor: pointer;
        border: 3px solid #8b9bed;
        box-shadow: 0 2px 5px rgba(102, 126, 234, 0.2);
        margin-top: -7px;
        transition: all 0.2s ease;
    }

    #version-slider:hover::-webkit-slider-thumb {
        transform: scale(1.15);
        background: #667eea;
        border-color: #667eea;
        box-shadow: 0 3px 8px rgba(102, 126, 234, 0.35);
    }

    #version-slider::-moz-range-thumb {
        width: 20px;
        height: 20px;
        background: #fff;
        border-radius: 50%;
        cursor: pointer;
        border: 3px solid #8b9bed;
        box-shadow: 0 2px 5px rgba(102, 126, 234, 0.2);
        transition: all 0.2s ease;
    }

    #version-slider:hover::-moz-range-thumb {
        transform: scale(1.15);
        background: #667eea;
        border-color: #667eea;
        box-shadow: 0 3px 8px rgba(102, 126, 234, 0.35);
    }

    #version-count-display { font-weight: 600; color: #4c63d2; min-width: 20px; text-align: center; }
    .password-input-wrapper {
        position: relative;
        flex: 1;
        display: flex;
        align-items: center;
    }
    .password-input-wrapper .config-input {
        padding-right: 40px;
    }
    .visibility-toggle-btn {
        position: absolute;
        right: 0;
        top: 0;
        height: 100%;
        width: 40px;
        background: transparent;
        border: none;
        cursor: pointer;
        font-size: 1.1rem;
        color: #888;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: color 0.2s;
    }
    .visibility-toggle-btn:hover {
        color: #333;
    }
    .mindmap-header .panel-title { color: white; }
    #edit-node-input {
        height: 120px;
        margin-bottom: 1rem;
    }
    .context-menu {
        position: absolute;
        z-index: 3000;
        background-color: #ffffff;
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        padding: 6px 0;
        min-width: 150px;
        font-size: 0.9rem;
        list-style: none;
        user-select: none;
    }

    .context-menu-item {
        padding: 8px 16px;
        cursor: pointer;
        color: #333;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .context-menu-item:hover {
        background-color: #f5f5f5;
    }
    .info-modal-content {
        line-height: 1.6;
        color: #333;
        padding: 1rem 1.5rem;
    }
    .info-modal-content h2 {
        font-size: 1.5rem;
        color: #4c63d2;
        margin-top: 1.5rem;
        margin-bottom: 1rem;
        padding-bottom: 0.5rem;
        border-bottom: 2px solid #eee;
    }
    .info-modal-content h2:first-of-type {
        margin-top: 0;
    }
    .info-modal-content h3 {
        font-size: 1.2rem;
        color: #667eea;
        margin-top: 1.2rem;
        margin-bottom: 0.8rem;
    }
    .info-modal-content p, .info-modal-content ul {
        margin-bottom: 1rem;
    }
    .info-modal-content ul {
        list-style-position: outside;
        padding-left: 1.5rem;
    }
    .info-modal-content li {
        margin-bottom: 0.5rem;
    }
    .info-modal-content li > ul {
        margin-top: 0.5rem;
        margin-bottom: 0.5rem;
    }
    .info-modal-content strong {
        color: #5a67d8;
    }
    .info-modal-content code {
        background-color: rgba(102, 126, 234, 0.1);
        padding: 0.2em 0.4em;
        border-radius: 4px;
        font-family: monospace;
        color: #4c63d2;
        font-weight: 600;
    }
</style>
</head>
<body>
<div class="header">
    <h1>AiMarkmap <span class="ai-badge">AI Powered</span></h1>
    <div class="header-right">
        <button id="info-btn" class="github-link" style="background:none; border:none; cursor:pointer; padding:0; color:white;" data-t-title="helpBtnTitle">
            <svg class="github-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="28" height="28">
                <path d="M0 0h24v24H0z" fill="none"></path>
                <path d="M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z"></path>
            </svg>
        </button>
        <a href="https://github.com/kongkongyo/Ai-Markmap" title="View on GitHub" target="_blank" rel="noopener noreferrer" class="github-link">
            <svg class="github-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></svg>
        </a>
        <div id="lang-switcher">
            <button data-lang="zh" class="lang-btn">中文</button>
            <button data-lang="en" class="lang-btn">EN</button>
        </div>
    </div>
</div>
<div class="container">
    <div class="editor-panel">
        <div class="panel-header">
            <button class="control-btn" id="prompt-settings-btn" data-t="promptSettingsBtn"></button>
            <button class="control-btn" id="settings-btn" onclick="openSettingsModal()" data-t="apiSettingsBtn"></button>
        </div>
        <div class="panel-section">
             <div class="config-row">
                <span class="config-label" data-t="modelLabel"></span>
                <div class="model-input-wrapper">
                    <div class="model-container">
                        <select id="model-select" class="model-select">
                            <option value="custom">自定义</option>
                            <option value="gpt-4o-mini" selected>gpt-4o-mini</option>
                        </select>
                        <button class="query-models-btn" id="query-models-btn" onclick="queryAvailableModels()" data-t="queryBtn"></button>
                    </div>
                    <input type="text" id="custom-model-input" class="config-input hidden" data-t-placeholder="customModelInputPlaceholder">
                </div>
            </div>
        </div>
        <div class="panel-section">
            <div class="config-row">
                <span class="config-label" data-t="versionsLabel"></span>
                <input type="range" id="version-slider" min="1" max="5" value="3">
                <span id="version-count-display">3</span>
            </div>
        </div>
        <div class="panel-section">
            <div class="button-row">
                <button class="control-btn ai-btn" id="generate-btn" onclick="generateWithAI()" data-t="generateBtn"></button>
                <button class="control-btn ai-btn" id="paste-generate-btn" onclick="pasteAndGenerate()" data-t="pasteGenerateBtn"></button>
            </div>
            <div class="button-row">
                <button class="control-btn view-btn" id="show-original-btn" onclick="switchView('original')" data-t="showOriginalBtn"></button>
                <button class="control-btn markdown-btn" id="show-markdown-btn" onclick="switchView('markdown')" data-t="showMarkdownBtn"></button>
                <button class="control-btn clear-btn" id="clear-btn" onclick="clearContent()" data-t="clearBtn"></button>
            </div>
        </div>
        <div class="input-section">
            <textarea id="topic-input" class="text-input" data-t-placeholder="topicInputPlaceholder"></textarea>
            <textarea id="content-display" class="content-display" style="display: none;" data-t-placeholder="contentDisplayPlaceholder"></textarea>
        </div>
    </div>
    <div class="mindmap-panel">
        <div class="mindmap-header">
            <div class="panel-title" data-t="mindmapPreviewTitle"></div>
            <div id="results-tabs" class="results-tabs"></div>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <button id="fullscreen-btn" class="export-btn" onclick="toggleFullScreen()"></button>
                <button id="export-svg-btn" class="export-btn" onclick="exportSVG()" data-t="exportSvgBtn" disabled></button>
                <button id="export-png-btn" class="export-btn" onclick="exportPNG()" data-t="exportPngBtn" disabled></button>
            </div>
        </div>
        <div class="mindmap-container" id="mindmap-container">
            <svg id="mindmap"></svg>
            <div id="loading-overlay" class="loading-overlay" style="display: none;">
                <div class="spinner-container">
                    <div class="loading-spinner"></div>
                    <span id="timer-display"></span>
                </div>
                <div data-t="thinkingMessage"></div>
                <div class="status-message" id="status-message"></div>
            </div>
        </div>
    </div>
</div>

<div id="settings-modal" class="modal-overlay hidden">
    <div class="modal-content">
        <button class="modal-close-btn" onclick="closeSettingsModal()">&times;</button>
        <div class="panel-header">
            <div class="panel-title" data-t="apiSettingsTitle"></div>
        </div>
        <div class="ai-config">
            <div class="config-row">
                <span class="config-label" data-t="apiUrlLabel"></span>
                <input type="text" id="api-url" class="config-input" data-t-placeholder="apiUrlPlaceholder" />
            </div>
            <div class="config-row">
                <span class="config-label" data-t="apiKeyLabel"></span>
                <div class="password-input-wrapper">
                    <input type="password" id="api-key" class="config-input" data-t-placeholder="apiKeyPlaceholder" />
                    <button type="button" id="toggle-api-key-visibility" class="visibility-toggle-btn" data-t-title="toggleVisibilityTitle">👁️</button>
                </div>
            </div>
            <div class="button-row">
                <button class="control-btn ai-btn" onclick="saveAndCloseSettings()" data-t="saveAndCloseBtn"></button>
            </div>
        </div>
    </div>
</div>

<div id="prompt-modal" class="modal-overlay hidden">
    <div class="modal-content">
        <button class="modal-close-btn" onclick="closePromptModal()">&times;</button>
        <div class="panel-header">
            <div class="panel-title" data-t="promptSettingsTitle"></div>
        </div>
        <div class="ai-config">
            <div class="prompt-tip" data-t="promptTip"></div>
            <textarea id="prompt-input" class="text-input" style="height: 350px; min-height: 200px; margin-bottom: 1rem;" data-t-placeholder="promptInputPlaceholder"></textarea>
            <div class="button-row">
                <button class="control-btn ai-btn" onclick="saveAndClosePrompt()" data-t="saveAndCloseBtn"></button>
            </div>
        </div>
    </div>
</div>

<div id="edit-node-modal" class="modal-overlay hidden">
    <div class="modal-content">
        <button class="modal-close-btn" onclick="closeEditModal()">&times;</button>
        <div class="panel-header">
            <div class="panel-title" data-t="editNodeTitle"></div>
        </div>
        <div class="ai-config">
            <textarea id="edit-node-input" class="text-input" data-t-placeholder="editNodePlaceholder"></textarea>
            <div class="button-row">
                <button class="control-btn ai-btn" onclick="saveNodeEdit()" data-t="saveAndCloseBtn"></button>
            </div>
        </div>
    </div>
</div>

<div id="info-modal" class="modal-overlay hidden">
    <div class="modal-content" style="width: 800px; max-height: 80vh; display: flex; flex-direction: column;">
        <button class="modal-close-btn" onclick="closeInfoModal()">&times;</button>
        <div class="panel-header">
            <div class="panel-title" data-t="infoModalTitle"></div>
        </div>
        <div class="info-modal-content" style="overflow-y: auto; flex-grow: 1;">
            
        </div>
    </div>
</div>

<script>
let mm = null;
let transformer = null;
let debounceTimer = null;
let currentMarkdown = '';
let aiResults = [];
let activeResultIndex = -1;
let timerInterval = null;
let startTime = 0;
let currentViewMode = 'input';
let AI_PROMPT_TEMPLATE = '';
let editingNodeContext = null;

let currentLanguage = 'zh';

const translations = {
    zh: {
        'promptSettingsBtn': '📝 Prompt设置',
        'apiSettingsBtn': '⚙️ API设置',
        'modelLabel': '模型:',
        'queryBtn': '🔍 查询',
        'versionsLabel': '版本数量:',
        'generateBtn': '🚀 AI生成',
        'pasteGenerateBtn': '📋 粘贴并生成',
        'showOriginalBtn': '📄 显示原文',
        'showMarkdownBtn': '📝 显示Markdown',
        'clearBtn': '🗑️ 清空',
        'fullscreenBtn': '全屏显示(F11)',
        'exportPngBtn': '导出 PNG',
        'exportSvgBtn': '导出 SVG',
        'mindmapPreviewTitle': '🧠 思维导图预览',
        'thinkingMessage': 'AI正在思考中...',
        'apiSettingsTitle': '⚙️ API 设置',
        'apiUrlLabel': 'API地址:',
        'apiKeyLabel': 'API秘钥:',
        'saveAndCloseBtn': '💾 保存并关闭',
        'promptSettingsTitle': '📝 Prompt 设置',
        'promptTip': '请确保在Prompt模板中包含 <code>{{CONTENT}}</code>，它将被替换为左侧的输入内容。',
        'editNodeTitle': '✏️ 编辑节点',
        'deleteNodeBtn': '🗑️ 删除节点',
        'helpBtnTitle': '帮助与信息',
        'infoModalTitle': '使用说明、服务条款和隐私政策',
        'infoModalContentHtml': `
            <h2>使用说明</h2>
            <ul>
                <li><strong>API 设置:</strong> 首次使用，请点击右上角的 <code>⚙️ API设置</code> 按钮，填入您的 AI 服务商提供的 API 地址 (URL) 和密钥 (Key)。配置将自动保存在您的浏览器本地。</li>
                <li><strong>模型选择:</strong> 在左侧面板选择或输入您想使用的 AI 模型。点击 <code>🔍 查询</code> 可自动获取该 API 地址下支持的模型列表。</li>
                <li><strong>内容输入:</strong> 在左侧最大的输入框中，您可以输入一段描述性文本，或者直接粘贴已经格式化好的 Markdown 内容。</li>
                <li><strong>AI 生成:</strong> 输入描述性文本后，通过滑块选择希望 AI 生成的不同版本数量（1-5个），然后点击 <code>🚀 AI生成</code>。</li>
                <li><strong>版本切换:</strong> 生成成功后，思维导图预览区上方会出现版本选项卡 (如“版本1”, “版本2”)，点击即可切换查看不同版本。</li>
                <li><strong>编辑与查看:</strong>
                    <ul style="margin-top: 0.5rem;">
                        <li>在思维导图上对任意节点<strong>单击右键</strong>，可选择<strong>“编辑节点”</strong>或<strong>“删除节点”</strong>。</li>
                        <li>左侧的 <code>📝 显示Markdown</code> 按钮可以让你查看和编辑 AI 生成的 Markdown 源码。</li>
                    </ul>
                </li>
                <li><strong>导出与全屏:</strong> 使用预览区右上角的按钮可将当前思维导图导出为 <code>SVG</code> 或 <code>PNG</code> 图片，或进入全屏模式。</li>
            </ul>

            <h2>服务条款</h2>
            <p>当您使用 AiMarkmap 时，即表示您同意以下条款：</p>
            <ul>
                <li>您对自己输入到本产品中的所有内容（包括文本、API密钥等）负全部责任。您必须保证输入的内容不侵犯任何第三方权利，且不违反任何适用法律法规。</li>
                <li>禁止利用本产品进行任何形式的恶意行为，包括但不限于大量的、不合理的 API 请求、传播非法信息、或攻击第三方服务。</li>
            </ul>

            <h2>隐私政策</h2>
            <p>我们高度重视您的隐私。请仔细阅读以下关于我们如何处理您的数据的信息：</p>
            <h3>数据收集</h3>
            <p>本产品主要处理两类数据：</p>
            <ul>
                <li><strong>配置信息:</strong> 您输入的 API 地址、API 密钥、所选模型等配置。这些信息仅使用浏览器的 <code>localStorage</code> 技术存储在<strong>您自己的电脑上</strong>，用于简化您的后续使用，不会上传到 AiMarkmap 的服务器。</li>
                <li><strong>输入内容:</strong> 您为生成思维导图而输入的文本内容。</li>
            </ul>
            <p>本产品<strong>不使用</strong>任何第三方分析工具（如 Google Analytics）来追踪您的个人行为。</p>
            
            <h3>数据使用</h3>
            <p>您的所有数据处理均在<strong>浏览器端（客户端）</strong>完成。具体流程如下：</p>
            <ul>
                <li>您的 API 密钥和输入内容仅在您点击“AI生成”按钮时，由您的浏览器直接组合成一个请求，发送给您在设置中指定的第三方 AI 服务（如 OpenAI、Google AI 等）。</li>
                <li><strong>AiMarkmap 的服务器不存储、不中转、也无法看到</strong>您的 API 密钥和输入内容。数据传输路径为：您的浏览器 -> 您指定的 AI 服务提供商。</li>
            </ul>

            <h3>第三方服务</h3>
            <p>本产品作为一个客户端工具，会根据您的配置调用第三方 AI 服务。您发送的数据将受您所使用的 AI 服务提供商的隐私政策和数据使用条款约束。我们强烈建议您在使用前查阅相应服务商的官方隐私政策。</p>

            <h2>免责声明</h2>
            <ul>
                <li><strong>AI 生成内容的准确性：</strong>由 AI 模型生成的所有内容仅供参考。我们不保证其准确性、完整性或适用性。您需要自行判断并对使用这些结果所造成的一切后果负责。</li>
                <li><strong>服务可用性：</strong>由于本产品依赖于网络连接和第三方 API 服务的稳定性，我们不承诺服务 100% 不间断或无错误。因网络问题、API 服务商故障或您自身配置错误导致的服务不可用，我们不承担任何责任。</li>
            </ul>`,
        
        'customModelInputPlaceholder': '输入自定义模型名称',
        'topicInputPlaceholder': '可直接输入或粘贴Markdown，或输入普通文本后点击“AI生成”...',
        'contentDisplayPlaceholder': '编辑内容...',
        'apiUrlPlaceholder': 'AI API地址',
        'apiKeyPlaceholder': 'API密钥',
        'toggleVisibilityTitle': '显示/隐藏密钥',
        'promptInputPlaceholder': '在此编辑AI Prompt模板...',
        'editNodePlaceholder': '输入节点的新内容...',

        'js_generating': '生成中...',
        'js_exporting': '导出中...',
        'js_querying': '查询中...',
        'js_exit_fullscreen': '退出全屏(F11)',
        'js_fullscreen': '全屏显示(F11)',
        'js_status_requesting': '正在发起AI请求...',
        'js_status_generated': (s, n) => `已成功生成 ${s}/${n} 个版本...`,
        'js_status_done': (n) => `生成完成！共 ${n} 个有效版本。`,
        'js_tab_version': (i) => `版本 ${i + 1}`,
        'js_alert_no_content': '请先输入内容！',
        'js_alert_no_api_config': '请先点击右上角“API设置”配置API地址和密钥！',
        'js_alert_no_custom_model': '请在自定义输入框中填写模型名称！',
        'js_alert_all_failed': '所有AI生成请求均失败或返回空内容。请检查API设置和网络。',
        'js_alert_gen_failed': (msg) => `AI生成失败: ${msg}`,
        'js_alert_no_clipboard': '您的浏览器不支持剪贴板 API，请手动粘贴内容。',
        'js_alert_clipboard_empty': '剪贴板内容为空。',
        'js_alert_clipboard_error': '无法读取剪贴板内容。\n请确保页面处于激活状态，并已授予浏览器读取剪贴板的权限。',
        'js_alert_query_no_config': '请先在设置中配置API地址和密钥！',
        'js_alert_query_failed': (msg) => `查询模型失败: ${msg}`,
        'js_alert_query_success': (n) => `成功获取到 ${n} 个可用模型！`,
        'js_alert_no_mindmap': '找不到思维导图，无法导出。',
        'js_alert_export_error': (type) => `导出${type}图片时发生错误，请稍后重试。`,
        
        'defaultMarkdown': `# 🤖 AI思维导图生成 - AiMarkmap

## ✨ 新功能特性
### 🎯 智能生成
- ✨ **自定义生成版本数量 (1-5)**
- AI驱动的内容创建
### 🔧 自定义配置
- 便捷的模型选择
- 弹窗配置API密钥
- 个性化设置

## 🚀 使用流程
### 📝 输入内容
- 在左侧输入框描述内容
- 或直接粘贴Markdown
### 🤖 AI处理
- **拖动滑块选择版本数**
- 点击生成按钮
### 🎨 可视化展示
- **点击选项卡切换不同版本**
- 实时预览思维导图
- 一键导出SVG&PNG图片`,
        'defaultPrompt': `{{CONTENT}}
请按以下设定的思维导图架构师的身份对以上内容执行任务。

# Role: 思维导图架构师

## Profile
- description: 精通信息结构提取与层次关系分析，能够将复杂文本内容转化为清晰、分层的思维导图格式，便于阅读与理解。
- background: 拥有丰富的信息架构设计经验，熟悉多种内容结构优化方法，擅长运用Markdown及视觉元素增强内容表现力。
- personality: 细致严谨，逻辑清晰，注重条理性与用户体验，表达简洁明了。
- expertise: 信息架构设计、内容层次化、结构化表达、Markdown思维导图制作。
- target_audience: 内容编辑人员、文档撰写者、项目管理者、学习者及需要清晰信息结构的用户群体。

## Skills

1. 信息结构设计
   - 层级划分: 根据内容逻辑精准划分多层级结构
   - 关系梳理: 明确主次、分支及关联节点
   - 内容细化: 优化内容条目，细化分点展开
   - 逻辑优化: 保持结构简洁且易读

2. Markdown及可视化表达
   - 思维导图格式制作: 灵活使用#、##、###等级标题表达层次
   - 列表运用: 以条目列表形式呈现节点内容
   - 语言保持: 保持原文语言与用词
   - Emoji增强: 合理使用Emoji增强视觉导向与可读性

3. Rules

1. 基本原则：
   - 原文尊重：所有内容必须保留原文句子，杜绝改写或删减关键内容
   - 结构清晰：层级分明，结构简洁，避免内容堆叠不清晰
   - 语言一致：输出语言应与原文本主要语言保持一致
   - 可视增强：尽量融合Emoji，增强层次感和视觉舒适度


2. 行为准则：
   - 不添不减：不得添加任何解释、观点或额外信息
   - 句式优化：适度调整句式以提升表达通顺度和条理明晰
   - 内容拆分：长句或内容过多时合理拆分并保持逻辑完整
   - 专业严谨：坚持专业风格，避免模糊和歧义表述


3. 限制条件：
   - 不允许自创内容：不加入个人见解或未出现的信息
   - 禁止格式错误：排版清晰，禁止Markdown语法错误
   - 中心主题限制：中心主题字数限制10个字左右
   - 层级限制：最少3级，层级数可根据内容合理扩展无上限

## Workflows

- 目标: 将原始文本内容转化为清晰分层的思维导图Markdown格式，便于直接阅读和内容解析
- 步骤 1: 彻底阅读并理解原始内容，分析其内在逻辑和层级关系
- 步骤 2: 按照层级使用#标题标记，条目采用列表形式排列，确保不少于三级层级
- 步骤 3: 对长句进行分点拆解，调整句式增强表述清晰度，并合适插入Emoji提升视觉效果
- 步骤 4: 最终输出为纯Markdown格式，只输出 Markdown文本本体，不要使用代码块包裹。
- 预期结果: 输出符合规范的Markdown格式思维导图文本，层级明晰，内容完整，语言统一，无任何附加解释或内容

## Initialization
作为思维导图架构师，你必须遵守上述Rules，按照Workflows执行任务。`
    },
    en: {
        'promptSettingsBtn': '📝 Prompt Settings',
        'apiSettingsBtn': '⚙️ API Settings',
        'modelLabel': 'Model:',
        'queryBtn': '🔍 Query',
        'versionsLabel': 'Versions:',
        'generateBtn': '🚀 AI Generate',
        'pasteGenerateBtn': '📋 Paste & Generate',
        'showOriginalBtn': '📄 Show Original',
        'showMarkdownBtn': '📝 Show Markdown',
        'clearBtn': '🗑️ Clear',
        'fullscreenBtn': 'Fullscreen (F11)',
        'exportPngBtn': 'Export PNG',
        'exportSvgBtn': 'Export SVG',
        'mindmapPreviewTitle': '🧠 Mind Map Preview',
        'thinkingMessage': 'AI is thinking...',
        'apiSettingsTitle': '⚙️ API Settings',
        'apiUrlLabel': 'API URL:',
        'apiKeyLabel': 'API Key:',
        'saveAndCloseBtn': '💾 Save & Close',
        'promptSettingsTitle': '📝 Prompt Settings',
        'promptTip': 'Please make sure to include <code>{{CONTENT}}</code> in the prompt template, which will be replaced with the input content from the left.',
        'editNodeTitle': '✏️ Edit Node',
        'deleteNodeBtn': '🗑️ Delete Node',
        'helpBtnTitle': 'Help & Information',
        'infoModalTitle': 'Instructions, Terms & Privacy Policy',
        'infoModalContentHtml': `
            <h2>Instructions</h2>
            <ul>
                <li><strong>API Settings:</strong> On first use, click the <code>⚙️ API Settings</code> button in the top right to enter the API URL and Key provided by your AI service provider. The configuration will be saved locally in your browser.</li>
                <li><strong>Model Selection:</strong> In the left panel, select or enter the AI model you want to use. Click <code>🔍 Query</code> to automatically fetch a list of supported models from the API URL.</li>
                <li><strong>Content Input:</strong> In the largest input box on the left, you can enter descriptive text or paste pre-formatted Markdown content.</li>
                <li><strong>AI Generation:</strong> After entering descriptive text, use the slider to select the number of different versions you want the AI to generate (1-5), then click <code>🚀 AI Generate</code>.</li>
                <li><strong>Switching Versions:</strong> After successful generation, version tabs (e.g., "Version 1", "Version 2") will appear above the mind map preview area. Click to view different versions.</li>
                <li><strong>Editing and Viewing:</strong>
                    <ul style="margin-top: 0.5rem;">
                        <li>On the mind map, <strong>right-click</strong> any node to select <strong>"Edit Node"</strong> or <strong>"Delete Node"</strong>.</li>
                        <li>The <code>📝 Show Markdown</code> button on the left allows you to view and edit the AI-generated Markdown source.</li>
                    </ul>
                </li>
                <li><strong>Export & Fullscreen:</strong> Use the buttons in the top right of the preview area to export the current mind map as an <code>SVG</code> or <code>PNG</code> image, or enter fullscreen mode.</li>
            </ul>

            <h2>Terms of Service</h2>
            <p>By using AiMarkmap, you agree to the following terms:</p>
            <ul>
                <li>You are solely responsible for all content (including text, API keys, etc.) you input into this product. You must ensure that the input content does not infringe on any third-party rights and does not violate any applicable laws and regulations.</li>
                <li>You are prohibited from using this product for any form of malicious activity, including but not limited to, making a large number of unreasonable API requests, disseminating illegal information, or attacking third-party services.</li>
            </ul>

            <h2>Privacy Policy</h2>
            <p>We take your privacy very seriously. Please read the following information carefully about how we handle your data:</p>
            <h3>Data Collection</h3>
            <p>This product primarily handles two types of data:</p>
            <ul>
                <li><strong>Configuration Information:</strong> The API URL, API Key, selected model, and other settings you enter. This information is stored <strong>only on your own computer</strong> using the browser's <code>localStorage</code> technology to simplify your subsequent use and is not uploaded to AiMarkmap's servers.</li>
                <li><strong>Input Content:</strong> The text content you provide to generate mind maps.</li>
            </ul>
            <p>This product <strong>does not use</strong> any third-party analytics tools (like Google Analytics) to track your personal behavior.</p>

            <h3>Data Usage</h3>
            <p>All of your data processing is done on the <strong>client-side (in your browser)</strong>. The process is as follows:</p>
            <ul>
                <li>Your API key and input content are combined into a request by your browser and sent directly to the third-party AI service you specify in the settings (such as OpenAI, Google AI, etc.) only when you click the "AI Generate" button.</li>
                <li><strong>AiMarkmap's servers do not store, proxy, or have any visibility into</strong> your API key and input content. The data transmission path is: Your Browser -> Your Specified AI Service Provider.</li>
            </ul>

            <h3>Third-Party Services</h3>
            <p>As a client-side tool, this product calls third-party AI services based on your configuration. The data you send is subject to the privacy policy and data usage terms of the AI service provider you use. We strongly recommend that you review the official privacy policies of the respective service providers before use.</p>

            <h2>Disclaimer</h2>
            <ul>
                <li><strong>Accuracy of AI-Generated Content:</strong> All content generated by AI models is for reference only. We do not guarantee its accuracy, completeness, or suitability. You need to judge for yourself and are responsible for all consequences arising from the use of these results.</li>
                <li><strong>Service Availability:</strong> As this product relies on network connectivity and the stability of third-party API services, we do not promise that the service will be 100% uninterrupted or error-free. We do not assume any responsibility for service unavailability caused by network issues, API provider failures, or your own configuration errors.</li>
            </ul>`,

        'customModelInputPlaceholder': 'Enter custom model name',
        'topicInputPlaceholder': 'Enter or paste Markdown directly, or input text and click "AI Generate"...',
        'contentDisplayPlaceholder': 'Edit content...',
        'apiUrlPlaceholder': 'AI API Address',
        'apiKeyPlaceholder': 'API Key',
        'toggleVisibilityTitle': 'Show/Hide Key',
        'promptInputPlaceholder': 'Edit AI Prompt template here...',
        'editNodePlaceholder': 'Enter the new content for the node...',

        'js_generating': 'Generating...',
        'js_exporting': 'Exporting...',
        'js_querying': 'Querying...',
        'js_exit_fullscreen': 'Exit Fullscreen (F11)',
        'js_fullscreen': 'Fullscreen (F11)',
        'js_status_requesting': 'Initiating AI request...',
        'js_status_generated': (s, n) => `Successfully generated ${s}/${n} versions...`,
        'js_status_done': (n) => `Generation complete! ${n} valid versions available.`,
        'js_tab_version': (i) => `Version ${i + 1}`,
        'js_alert_no_content': 'Please enter content first!',
        'js_alert_no_api_config': 'Please configure API URL and Key in "API Settings" first!',
        'js_alert_no_custom_model': 'Please enter a model name in the custom input field!',
        'js_alert_all_failed': 'All AI generation requests failed or returned empty content. Please check API settings and network.',
        'js_alert_gen_failed': (msg) => `AI generation failed: ${msg}`,
        'js_alert_no_clipboard': "Your browser does not support the Clipboard API. Please paste the content manually.",
        'js_alert_clipboard_empty': 'Clipboard is empty.',
        'js_alert_clipboard_error': 'Could not read from clipboard.\nPlease ensure the page is active and has permission to read the clipboard.',
        'js_alert_query_no_config': 'Please configure API URL and Key in settings first!',
        'js_alert_query_failed': (msg) => `Query models failed: ${msg}`,
        'js_alert_query_success': (n) => `Successfully fetched ${n} available models!`,
        'js_alert_no_mindmap': 'Could not find the mind map to export.',
        'js_alert_export_error': (type) => `An error occurred while exporting the ${type} image. Please try again later.`,
        
        'defaultMarkdown': `# 🤖 AI Mind Map Generation - AiMarkmap

## ✨ Features
### 🎯 Smart Generation
- ✨ **Custom number of versions (1-5)**
- AI-driven content creation
### 🔧 Custom Configuration
- Easy model selection
- API key configuration via modal
- Personalized settings

## 🚀 How to Use
### 📝 Input Content
- Describe content in the left input box
- Or paste Markdown directly
### 🤖 AI Processing
- **Use the slider to select version count**
- Click the generate button
### 🎨 Visualization
- **Click tabs to switch between versions**
- Real-time mind map preview
- One-click PNG export`,
        'defaultPrompt': `You are an expert in information architecture, skilled at extracting the structure and hierarchy of information. Please output the following content in Markdown format for a mind map: "{{CONTENT}}".

Please adhere to the following requirements:

1.  Content Analysis:
    - Analyze the inherent logical structure of the content and elaborate on the hierarchy as much as possible, expanding on each point.

2.  Structural Requirements:
    - Keep the structure clear for easy reading and parsing.
    - Use clear hierarchies with #, ##, ###, etc., for different levels.
    - Use the original language of the text for all nodes.
    - Present items in the content as lists.
    - The central topic should be around 10 words.
    - There should be a minimum of 3 levels, with no maximum limit.
    - If a level or branch contains too much text, split the content into same-level items or create deeper levels to keep the structure clean and concise.

3.  Content Handling:
    - Preserve the original sentences.
    - Do not add explanations or extra comments.
    - Do not add your own opinions or information outside the provided text.
    - Minor sentence adjustments for clarity are acceptable.
    - Long or complex sentences can be broken down into bullet points.

4.  Enhance Visibility:
    - Use Emoji to improve readability where appropriate.

5.  Output Language:
    - If the main content of the original text is not Chinese, output all Markdown content in the language of the original text.

6.  Output Format:
    - The final output must be in pure Markdown format.
    - Output only the Markdown text itself.
    - Do not wrap the output in code blocks.`
    }
};

function setLanguage(lang) {
    if (!translations[lang]) return;

    const oldDefaultMarkdown = T('defaultMarkdown');
    const isShowingDefaultMarkdown = currentMarkdown === oldDefaultMarkdown;

    currentLanguage = lang;
    localStorage.setItem('ai-mindmap-language', lang);
    document.documentElement.lang = lang.split('-')[0];

    const t = translations[lang];

    document.querySelectorAll('[data-t]').forEach(el => {
        const key = el.dataset.t;
        if (t[key]) el.innerHTML = t[key];
    });
    
    document.querySelectorAll('[data-t-placeholder]').forEach(el => {
        const key = el.dataset.tPlaceholder;
        if (t[key]) el.placeholder = t[key];
    });

    document.querySelectorAll('[data-t-title]').forEach(el => {
        const key = el.dataset.tTitle;
        if (t[key]) el.title = t[key];
    });
    
    const infoModalContent = document.querySelector('#info-modal .info-modal-content');
    if (infoModalContent && t['infoModalContentHtml']) {
        infoModalContent.innerHTML = t['infoModalContentHtml'];
    }

    document.querySelectorAll('#lang-switcher .lang-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.lang === lang);
    });

    document.title = (lang === 'zh') ? 'AI思维导图生成 - AiMarkmap' : 'AI Mind Map Generation - AiMarkmap';

    if (isShowingDefaultMarkdown) {
        currentMarkdown = T('defaultMarkdown');
        updateMarkmap(currentMarkdown);
    }
    
    loadPrompt();

    handleFullScreenChange();
    updateAllButtonStates();
    if (aiResults.length > 0) {
        renderResultTabs();
        document.querySelectorAll('.result-tab-btn').forEach(btn => {
            btn.classList.toggle('active', parseInt(btn.dataset.index) === activeResultIndex);
        });
    }
}

function T(key, ...args) {
    const translation = translations[currentLanguage]?.[key];
    if (typeof translation === 'function') {
        return translation(...args);
    }
    return translation || key;
}
const topicInput = document.getElementById('topic-input');
const contentDisplay = document.getElementById('content-display');
const showOriginalBtn = document.getElementById('show-original-btn');
const showMarkdownBtn = document.getElementById('show-markdown-btn');
const settingsModal = document.getElementById('settings-modal');
const infoModal = document.getElementById('info-modal');
const editNodeModal = document.getElementById('edit-node-modal');
const versionSlider = document.getElementById('version-slider');
const versionCountDisplay = document.getElementById('version-count-display');
const generateBtn = document.getElementById('generate-btn');
const pasteGenerateBtn = document.getElementById('paste-generate-btn');
const promptModal = document.getElementById('prompt-modal');
const promptInput = document.getElementById('prompt-input');

const LAST_SUCCESSFUL_MODEL_KEY = 'ai-mindmap-last-successful-model';

const colorPalette = [
  '#3B82F6',
  '#16A34A',
  '#F97316',
  '#9333EA',
  '#E11D48',
  '#0891B2',
];

function getNodeColor(node) {
  if (node.depth === 0) return '#374151';
  const index = (node.depth - 1) % colorPalette.length;
  return colorPalette[index];
}

function openSettingsModal() { settingsModal.classList.remove('hidden'); }
function closeSettingsModal() { settingsModal.classList.add('hidden'); }
function saveAndCloseSettings() {
    autoCompleteApiUrl();
    saveConfig();
    closeSettingsModal();
    const apiUrl = document.getElementById('api-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();
    if (apiUrl && apiKey) { queryAvailableModels(true); }
}

function openInfoModal() { infoModal.classList.remove('hidden'); }
function closeInfoModal() { infoModal.classList.add('hidden'); }

function openPromptModal() {
    promptInput.value = AI_PROMPT_TEMPLATE;
    promptModal.classList.remove('hidden');
}

function closePromptModal() {
    promptModal.classList.add('hidden');
}

function saveAndClosePrompt() {
    const newPrompt = promptInput.value.trim();

    if (newPrompt) {
        if (newPrompt.includes('{{CONTENT}}')) {
            AI_PROMPT_TEMPLATE = newPrompt;
        } else {
            AI_PROMPT_TEMPLATE = newPrompt + '\n\n"{{CONTENT}}"';
        }
        localStorage.setItem('ai-mindmap-prompt', AI_PROMPT_TEMPLATE);
    } else {
        AI_PROMPT_TEMPLATE = T('defaultPrompt');
        localStorage.removeItem('ai-mindmap-prompt');
    }

    closePromptModal();
}

function updateVersionCountDisplay() {
    const count = versionSlider.value;
    versionCountDisplay.textContent = count;
}

function waitForLibraries() {
    return new Promise((resolve, reject) => {
        const checkInterval = setInterval(() => {
            if (window.markmap) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 100);
        setTimeout(() => {
            clearInterval(checkInterval);
            reject(new Error('核心库加载超时，请检查网络连接或刷新页面。'));
        }, 10000);
    });
}
async function init() {
    try {
        await waitForLibraries();
        const { Transformer, Markmap } = window.markmap;
        transformer = new Transformer();
        const svg = document.querySelector('#mindmap');
        
        mm = Markmap.create(svg, { 
            duration: 500, nodeMinHeight: 16, spacingVertical: 5, spacingHorizontal: 80, autoFit: true, fitRatio: 0.95, color: getNodeColor,
        });
        
        setupNodeInteraction();

        document.getElementById('lang-switcher').addEventListener('click', (e) => {
            if (e.target.matches('.lang-btn')) {
                const lang = e.target.dataset.lang;
                setLanguage(lang);
            }
        });

        document.getElementById('api-url').addEventListener('blur', autoCompleteApiUrl);
        
        document.getElementById('model-select').addEventListener('change', handleModelChange);
        ['api-url', 'api-key', 'model-select', 'custom-model-input'].forEach(id => {
            document.getElementById(id).addEventListener('input', saveConfig);
        });

        contentDisplay.addEventListener('input', handleDisplayEdit);
        topicInput.addEventListener('focus', () => switchView('input'));
        
        topicInput.addEventListener('input', handleTopicInput);

        document.addEventListener('fullscreenchange', handleFullScreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullScreenChange);
        document.addEventListener('mozfullscreenchange', handleFullScreenChange);
        document.addEventListener('MSFullscreenChange', handleFullScreenChange);

        document.querySelector('#settings-modal .modal-close-btn').addEventListener('click', closeSettingsModal);
        settingsModal.addEventListener('click', (e) => {
            if (e.target === settingsModal) { closeSettingsModal(); }
        });

        document.getElementById('info-btn').addEventListener('click', openInfoModal);
        document.querySelector('#info-modal .modal-close-btn').addEventListener('click', closeInfoModal);
        infoModal.addEventListener('click', (e) => {
            if (e.target === infoModal) { closeInfoModal(); }
        });
        
        document.getElementById('prompt-settings-btn').addEventListener('click', openPromptModal);
        document.querySelector('#prompt-modal .modal-close-btn').addEventListener('click', closePromptModal);
        promptModal.addEventListener('click', (e) => {
            if (e.target === promptModal) { closePromptModal(); }
        });

        editNodeModal.addEventListener('click', (e) => {
            if (e.target === editNodeModal) { closeEditModal(); }
        });

        versionSlider.addEventListener('input', () => {
            updateVersionCountDisplay();
            saveConfig();
        });
        
        document.getElementById('toggle-api-key-visibility').addEventListener('click', function() {
            const apiKeyInput = document.getElementById('api-key');
            const isPassword = apiKeyInput.type === 'password';
            apiKeyInput.type = isPassword ? 'text' : 'password';
            this.textContent = isPassword ? '🙈' : '👁️';
        });

        loadConfig();

        const savedLang = localStorage.getItem('ai-mindmap-language');
        const browserLang = navigator.language.split('-')[0];
        const initialLang = savedLang || (['zh', 'en'].includes(browserLang) ? browserLang : 'zh');
        setLanguage(initialLang);

        const apiUrl = document.getElementById('api-url').value.trim();
        const apiKey = document.getElementById('api-key').value.trim();
        if (apiUrl && apiKey) {
            queryAvailableModels(true);
        }

        handleModelChange();
        clearContent();
        updateVersionCountDisplay();

    } catch (error) {
        console.error('初始化失败:', error);
        alert(error.message);
    }
}

function autoCompleteApiUrl() {
    const input = document.getElementById('api-url');
    let url = input.value.trim();
    if (!url || url.includes('/chat/completions')) { return; }
    url = url.replace(/\/+$/, '');
    let correctedUrl;
    if (url.endsWith('/v1')) {
        correctedUrl = url + '/chat/completions';
    } else {
        correctedUrl = url + '/v1/chat/completions';
    }
    input.value = correctedUrl;
}

function saveConfig() {
    const config = {
        apiUrl: document.getElementById('api-url').value,
        apiKey: document.getElementById('api-key').value,
        model: document.getElementById('model-select').value,
        customModel: document.getElementById('custom-model-input').value,
        versionCount: document.getElementById('version-slider').value,
    };
    localStorage.setItem('ai-mindmap-config', JSON.stringify(config));
}

function loadConfig() {
    try {
        const configStr = localStorage.getItem('ai-mindmap-config');
        const parsed = configStr ? JSON.parse(configStr) : {};

        document.getElementById('api-url').value = parsed.apiUrl || '';
        document.getElementById('api-key').value = parsed.apiKey || '';

        if (parsed.versionCount) {
            document.getElementById('version-slider').value = parsed.versionCount;
        }

        const modelSelect = document.getElementById('model-select');
        const customModelInput = document.getElementById('custom-model-input');
        
        let modelToSet;

        const lastSuccessfulModel = localStorage.getItem(LAST_SUCCESSFUL_MODEL_KEY);
        if (lastSuccessfulModel) {
            modelToSet = lastSuccessfulModel;
        } else {
            modelToSet = parsed.model || 'gpt-4o-mini';
        }
        
        if ([...modelSelect.options].some(opt => opt.value === modelToSet)) {
            modelSelect.value = modelToSet;
            customModelInput.value = parsed.customModel || '';
        } else {
            modelSelect.value = 'custom';
            customModelInput.value = modelToSet;
        }

    } catch(e) {
        console.error("解析本地配置失败", e);
        localStorage.removeItem('ai-mindmap-config');
    }
}

function loadPrompt() {
    const savedPrompt = localStorage.getItem('ai-mindmap-prompt');
    AI_PROMPT_TEMPLATE = savedPrompt || T('defaultPrompt');
}

function handleModelChange() {
    const modelSelect = document.getElementById('model-select');
    const customModelInput = document.getElementById('custom-model-input');
    customModelInput.classList.toggle('hidden', modelSelect.value !== 'custom');
}

async function pasteAndGenerate() {
    if (!navigator.clipboard) {
        alert(T('js_alert_no_clipboard'));
        return;
    }

    try {
        const text = await navigator.clipboard.readText();
        if (!text.trim()) {
            alert(T('js_alert_clipboard_empty'));
            return;
        }
        
        topicInput.value = text;
        switchView('input');
        await generateWithAI();

    } catch (err) {
        console.error("无法读取剪贴板:", err);
        alert(T('js_alert_clipboard_error'));
    }
}

async function queryAvailableModels(isSilent = false) {
    const apiUrl = document.getElementById('api-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();
    if (!apiUrl || !apiKey) {
        if (!isSilent) {
            alert(T('js_alert_query_no_config'));
            openSettingsModal();
        }
        return;
    }
    
    const queryBtn = document.getElementById('query-models-btn');
    const originalText = queryBtn.innerHTML;
    queryBtn.disabled = true;
    if (!isSilent) { queryBtn.innerHTML = T('js_querying'); }
    
    try {
        let modelsApiUrl = apiUrl.replace(/\/chat\/completions$/, '/models');
        if (!modelsApiUrl.endsWith('/models')) {
            const baseUrlMatch = apiUrl.match(/^(https?:\/\/.+?\/v\d+)/);
            if (baseUrlMatch) { modelsApiUrl = `${baseUrlMatch[1]}/models`;
            } else { throw new Error("无法从API地址推断出/models路径，请检查API地址格式。"); }
        }
        
        const response = await fetch(modelsApiUrl, {
            method: 'GET', headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' }
        });
        
        if (!response.ok) { 
            const errorText = await response.text();
            throw new Error(`查询失败: ${response.status} - ${response.statusText}. 响应: ${errorText}`); 
        }
        
        const data = await response.json();
        const models = (data.data || data.models || []).map(m => m.id || m.name || m).filter(Boolean);
        if (models.length === 0) { throw new Error('未找到可用模型'); }
        
        const modelSelect = document.getElementById('model-select');
        const currentSelectedValue = modelSelect.value === 'custom' ? document.getElementById('custom-model-input').value : modelSelect.value;
        modelSelect.innerHTML = '<option value="custom">自定义</option>';
        models.forEach(modelId => {
            const option = document.createElement('option');
            option.value = option.textContent = modelId;
            modelSelect.appendChild(option);
        });
        
        const optionExists = models.includes(currentSelectedValue);
        if(optionExists) { modelSelect.value = currentSelectedValue;
        } else {
            modelSelect.value = 'custom';
            document.getElementById('custom-model-input').value = currentSelectedValue;
        }
        
        handleModelChange();
        saveConfig();
        
        if (!isSilent) {
            alert(T('js_alert_query_success', models.length));
        } else {
            console.log(`[Silent Query] Successfully fetched ${models.length} models.`);
        }
    } catch (error) {
        console.error('查询模型失败:', error);
        if (!isSilent) alert(T('js_alert_query_failed', error.message));
    } finally {
        queryBtn.disabled = false;
        queryBtn.innerHTML = T('queryBtn');
    }
}

async function generateWithAI() {
    const content = topicInput.value.trim();
    if (!content) { alert(T('js_alert_no_content')); return; }

    const apiUrl = document.getElementById('api-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();
    const modelSelect = document.getElementById('model-select');
    let model = modelSelect.value === 'custom' ? document.getElementById('custom-model-input').value.trim() : modelSelect.value;
    
    if (modelSelect.value === 'custom' && !model) { alert(T('js_alert_no_custom_model')); return; }
    if (!apiUrl || !apiKey) { alert(T('js_alert_no_api_config')); openSettingsModal(); return; }

    const loadingOverlay = document.getElementById('loading-overlay');
    const statusMessage = document.getElementById('status-message');
    const timerDisplay = document.getElementById('timer-display');
    const generatingText = T('js_generating');

    generateBtn.disabled = true;
    pasteGenerateBtn.disabled = true;
    generateBtn.innerHTML = generatingText;
    pasteGenerateBtn.innerHTML = generatingText;

    loadingOverlay.style.display = 'flex';
    statusMessage.textContent = T('js_status_requesting');
    startTimer(timerDisplay);
    clearAiResults();

    try {
        const fetchPromises = [];
        const numVersions = parseInt(versionSlider.value, 10);
        for (let i = 0; i < numVersions; i++) {
            fetchPromises.push(
                fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                    body: JSON.stringify({
                        model: model,
                        messages: [{ role: 'user', content: AI_PROMPT_TEMPLATE.replace('{{CONTENT}}', content) }],
                        max_tokens: 2000,
                        temperature: 0.6 + i * 0.15
                    })
                })
            );
        }

        const responses = await Promise.allSettled(fetchPromises);
        let successfulResults = 0;

        for (const result of responses) {
            if (result.status === 'fulfilled') {
                const response = result.value;
                 if (response.ok) {
                    try {
                        const data = await response.json();
                        const markdownContent = data.choices?.[0]?.message?.content;
                        if (markdownContent) {
                            const { root } = transformer.transform(markdownContent.trim());
                            aiResults.push({ markdown: markdownContent.trim(), root: root });
                            successfulResults++;
                            statusMessage.textContent = T('js_status_generated', successfulResults, numVersions);
                        }
                    } catch (e) { console.error('解析AI响应失败:', e); }
                }
            } else {
                console.error('一个AI请求失败:', result.reason);
            }
        }
        
        if (aiResults.length > 0) {
            localStorage.setItem(LAST_SUCCESSFUL_MODEL_KEY, model);
            statusMessage.textContent = T('js_status_done', aiResults.length);
            renderResultTabs();
            switchToResult(0);
            switchView('markdown');
            setTimeout(() => { loadingOverlay.style.display = 'none'; }, 1000);
        } else {
            throw new Error(T('js_alert_all_failed'));
        }

    } catch (error) {
        console.error('AI生成失败:', error);
        alert(T('js_alert_gen_failed', error.message));
        loadingOverlay.style.display = 'none';
        updateMarkmap(currentMarkdown);
    } finally {
        stopTimer();
        generateBtn.disabled = false;
        pasteGenerateBtn.disabled = false;
        generateBtn.innerHTML = T('generateBtn');
        pasteGenerateBtn.innerHTML = T('pasteGenerateBtn');
        updateAllButtonStates();
    }
}

function handleTopicInput() {
    const text = this.value;
    if (text.trim().startsWith('#')) {
        clearAiResults();
        currentMarkdown = text;
        debounceUpdate(currentMarkdown);
    } else {
        updateAllButtonStates();
    }
}

function handleDisplayEdit() {
    if (currentViewMode === 'markdown') {
        const newMarkdown = this.value;
        currentMarkdown = newMarkdown;

        if (activeResultIndex > -1 && aiResults[activeResultIndex]) {
            aiResults[activeResultIndex].markdown = newMarkdown;
            try {
                const { root } = transformer.transform(newMarkdown);
                aiResults[activeResultIndex].root = root;
            } catch (error) {
                console.error('Error parsing edited markdown:', error);
            }
        }
        
        debounceUpdate(newMarkdown);
    } else if (currentViewMode === 'original') {
        topicInput.value = this.value;
        updateAllButtonStates();
    }
}

function switchView(viewName) {
    currentViewMode = viewName;
    if (viewName === 'original') {
        contentDisplay.value = topicInput.value;
        contentDisplay.style.display = 'block';
        topicInput.style.display = 'none';
    } else if (viewName === 'markdown') {
        contentDisplay.value = currentMarkdown;
        contentDisplay.style.display = 'block';
        topicInput.style.display = 'none';
    } else {
        contentDisplay.style.display = 'none';
        topicInput.style.display = 'block';
    }
    updateAllButtonStates();
}

function clearContent() {
    topicInput.value = '';
    clearAiResults();
    currentMarkdown = T('defaultMarkdown');
    updateMarkmap(currentMarkdown);
    switchView('input');
    topicInput.focus();
}

function clearAiResults() {
    aiResults = [];
    activeResultIndex = -1;
    renderResultTabs();
}

function renderResultTabs() {
    const tabsContainer = document.getElementById('results-tabs');
    tabsContainer.innerHTML = '';
    if (aiResults.length > 1) {
        aiResults.forEach((_, index) => {
            const tab = document.createElement('button');
            tab.className = 'result-tab-btn';
            tab.textContent = T('js_tab_version', index);
            tab.dataset.index = index;
            tab.onclick = () => switchToResult(index);
            tabsContainer.appendChild(tab);
        });
    }
}

function switchToResult(index) {
    if (index < 0 || index >= aiResults.length) return;

    activeResultIndex = index;
    const result = aiResults[index];
    currentMarkdown = result.markdown;
    mm.setData(result.root);
    mm.fit();

    if (currentViewMode === 'markdown') {
        contentDisplay.value = currentMarkdown;
    }

    document.querySelectorAll('.result-tab-btn').forEach(btn => {
        btn.classList.toggle('active', parseInt(btn.dataset.index) === index);
    });
}

function updateAllButtonStates() {
    const hasOriginalContent = topicInput.value.trim() !== '';
    const hasManualMd = topicInput.value.trim().startsWith('#');
    const hasGeneratedMd = aiResults.length > 0;
    const isDefaultMd = !hasManualMd && !hasGeneratedMd && currentMarkdown === T('defaultMarkdown');
    
    const exportSvgBtn = document.getElementById('export-svg-btn');
    const exportPngBtn = document.getElementById('export-png-btn');

    showOriginalBtn.classList.toggle('active', currentViewMode === 'original');
    showMarkdownBtn.classList.toggle('active', currentViewMode === 'markdown');
    showOriginalBtn.disabled = !hasOriginalContent;
    showMarkdownBtn.disabled = !hasGeneratedMd && !hasManualMd;

    const canExport = !isDefaultMd;
    if (exportSvgBtn) exportSvgBtn.disabled = !canExport;
    if (exportPngBtn) exportPngBtn.disabled = !canExport;
}

function updateMarkmap(markdown) {
    if (!mm || !transformer) return;
    try {
        const { root } = transformer.transform(markdown);
        mm.setData(root);
    } catch (error) { console.error('渲染Markmap失败:', error); }
    updateAllButtonStates();
}

function debounceUpdate(markdown) {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => { updateMarkmap(markdown); mm.fit(); }, 300);
}

function startTimer(displayElement) {
    startTime = Date.now();
    displayElement.textContent = '0.0s';
    clearInterval(timerInterval);
    timerInterval = setInterval(() => {
        const elapsedSeconds = (Date.now() - startTime) / 1000;
        displayElement.textContent = `${elapsedSeconds.toFixed(1)}s`;
    }, 100);
}

function stopTimer() { clearInterval(timerInterval); }

function toggleFullScreen() {
    const mindmapPanel = document.querySelector('.mindmap-panel');
    const isFullScreen = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;

    if (!isFullScreen) {
        if (mindmapPanel.requestFullscreen) { mindmapPanel.requestFullscreen(); }
        else if (mindmapPanel.mozRequestFullScreen) { mindmapPanel.mozRequestFullScreen(); }
        else if (mindmapPanel.webkitRequestFullscreen) { mindmapPanel.webkitRequestFullscreen(); }
        else if (mindmapPanel.msRequestFullscreen) { mindmapPanel.msRequestFullscreen(); }
    } else {
        if (document.exitFullscreen) { document.exitFullscreen(); }
        else if (document.mozCancelFullScreen) { document.mozCancelFullScreen(); }
        else if (document.webkitExitFullscreen) { document.webkitExitFullscreen(); }
        else if (document.msExitFullscreen) { document.msExitFullscreen(); }
    }
}

function handleFullScreenChange() {
    const fullscreenBtn = document.getElementById('fullscreen-btn');
    const isFullScreen = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
    
    fullscreenBtn.textContent = isFullScreen ? T('js_exit_fullscreen') : T('js_fullscreen');

    if (mm) {
        setTimeout(() => { mm.fit(); }, 200);
    }
}

function getMindmapCssRules() {
    let cssText = '';
    const relevantSelectors = ['.markmap', 'text', 'path', 'line', 'circle', 'foreignObject'];
    for (const styleSheet of document.styleSheets) {
        try {
            if (styleSheet.cssRules) {
                for (const rule of styleSheet.cssRules) {
                    if (relevantSelectors.some(selector => rule.selectorText?.includes(selector))) {
                        cssText += rule.cssText;
                    }
                }
            }
        } catch (e) {
            console.warn("无法读取样式表中的CSS规则:", styleSheet.href, e);
        }
    }
    return cssText;
}

function createExportableSvg(svgElement) {
    const mainGroup = svgElement.querySelector('g');
    if (!mainGroup) return null;

    const bbox = mainGroup.getBBox();
    if (bbox.width === 0 || bbox.height === 0) return null;
    
    const svgClone = svgElement.cloneNode(true);
    
    svgClone.removeAttribute('style');
    
    svgClone.setAttribute('width', bbox.width);
    svgClone.setAttribute('height', bbox.height);
    svgClone.setAttribute('viewBox', `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`);
    
    const groupInClone = svgClone.querySelector('g');
    if(groupInClone) {
        groupInClone.removeAttribute('transform');
    }

    const style = document.createElement('style');
    style.textContent = getMindmapCssRules();
    svgClone.insertBefore(style, svgClone.firstChild);

    const serializer = new XMLSerializer();
    let svgString = serializer.serializeToString(svgClone);

    svgString = svgString.replace(/(\w+)?:?xlink=/g, 'xmlns:xlink=').replace(/NS\d+:href/g, 'xlink:href');

    return { svgString, width: bbox.width, height: bbox.height };
}

function downloadBlob(blob, fileName) {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = fileName;
    
    document.body.appendChild(link);
    link.click();
    
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}

async function exportSVG() {
    const exportBtn = document.getElementById('export-svg-btn');
    if (exportBtn.disabled) return;

    const mindmapSVG = document.querySelector('#mindmap');
    if (!mindmapSVG) {
        alert(T('js_alert_no_mindmap'));
        return;
    }
    
    const originalText = exportBtn.textContent;
    exportBtn.disabled = true;
    exportBtn.textContent = T('js_exporting');

    try {
        await mm.fit();
        const svgData = createExportableSvg(mindmapSVG);

        if (!svgData) {
            throw new Error(T('js_alert_no_mindmap'));
        }

        const svgBlob = new Blob([svgData.svgString], { type: 'image/svg+xml;charset=utf-8' });
        downloadBlob(svgBlob, `aimarkmap-${Date.now()}.svg`);

    } catch (error) {
        console.error('导出SVG失败:', error);
        alert(T('js_alert_export_error', 'SVG'));
    } finally {
        exportBtn.disabled = false;
        exportBtn.textContent = originalText;
    }
}

async function exportPNG() {
    const exportBtn = document.getElementById('export-png-btn');
    if (exportBtn.disabled) return;

    const mindmapSVG = document.querySelector('#mindmap');
    if (!mindmapSVG) {
        alert(T('js_alert_no_mindmap'));
        return;
    }

    const originalText = exportBtn.textContent;
    exportBtn.disabled = true;
    exportBtn.textContent = T('js_exporting');

    try {
        await mm.fit();
        const svgData = createExportableSvg(mindmapSVG);
        
        if (!svgData) {
            throw new Error(T('js_alert_no_mindmap'));
        }

        const margin = 20;
        const scale = 3; 
        const canvas = document.createElement('canvas');
        canvas.width = (svgData.width + margin * 2) * scale;
        canvas.height = (svgData.height + margin * 2) * scale;
        
        const ctx = canvas.getContext('2d');
        if (!ctx) throw new Error('无法获取Canvas上下文');
        
        ctx.imageSmoothingEnabled = false;

        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const dataUrl = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData.svgString)));
        
        const img = await new Promise((resolve, reject) => {
            const image = new Image();
            image.onload = () => resolve(image);
            image.onerror = (err) => reject(new Error('Failed to load SVG as image. ' + err));
            image.src = dataUrl;
        });
        
        if(img.decode) await img.decode();
        
        ctx.drawImage(img, margin * scale, margin * scale, svgData.width * scale, svgData.height * scale);

        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));

        if (blob) {
            downloadBlob(blob, `aimarkmap-${Date.now()}.png`);
        } else {
            throw new Error("Canvas toBlob failed.");
        }

    } catch (error) {
        console.error('导出PNG时发生意外错误:', error);
        alert(T('js_alert_export_error', 'PNG'));
    } finally {
        exportBtn.disabled = false;
        exportBtn.textContent = originalText;
    }
}


function openEditModal(originalText, lineIndex, prefix) {
    editingNodeContext = { lineIndex, prefix };
    const editInput = document.getElementById('edit-node-input');
    editInput.value = originalText;
    editNodeModal.classList.remove('hidden');
    editInput.focus();
    editInput.select();
}

function closeEditModal() {
    editingNodeContext = null;
    editNodeModal.classList.add('hidden');
}

function saveNodeEdit() {
    if (!editingNodeContext) return;

    const newText = document.getElementById('edit-node-input').value;
    const { lineIndex, prefix } = editingNodeContext;
    const newLine = prefix + newText;
    
    const lines = currentMarkdown.split('\n');
    if (lines[lineIndex] !== undefined) {
        lines[lineIndex] = newLine;
        currentMarkdown = lines.join('\n');
    }

    if (activeResultIndex > -1 && aiResults[activeResultIndex]) {
        aiResults[activeResultIndex].markdown = currentMarkdown;
        try {
            const { root } = transformer.transform(currentMarkdown);
            aiResults[activeResultIndex].root = root;
        } catch (error) {
            console.error('Error parsing edited markdown after node edit:', error);
        }
    }
    
    if (currentViewMode === 'markdown') {
        contentDisplay.value = currentMarkdown;
    }

    updateMarkmap(currentMarkdown);
    closeEditModal();
}

function collectNodeLines(node, linesSet) {
    const markmapNode = node.data; 
    if (markmapNode?.payload?.lines) {
        const [start, end] = markmapNode.payload.lines;
        for (let i = start; i < end; i++) {
            linesSet.add(i);
        }
    }
    if (node.children) {
        for (const child of node.children) {
            collectNodeLines(child, linesSet);
        }
    }
}

function deleteNode(nodeToDelete) {
    if (!nodeToDelete) return;

    const linesToDelete = new Set();
    collectNodeLines(nodeToDelete, linesToDelete);

    if (linesToDelete.size === 0) {
        console.warn("Could not find line numbers for node deletion.", nodeToDelete);
        return;
    }
    
    const lines = currentMarkdown.split('\n');
    const newLines = lines.filter((_, i) => !linesToDelete.has(i));
    currentMarkdown = newLines.join('\n');

    if (activeResultIndex > -1 && aiResults[activeResultIndex]) {
        aiResults[activeResultIndex].markdown = currentMarkdown;
        try {
            const { root } = transformer.transform(currentMarkdown);
            aiResults[activeResultIndex].root = root;
        } catch (error) {
            console.error('Error parsing markdown after node deletion:', error);
        }
    }
    
    if (currentViewMode === 'markdown') {
        contentDisplay.value = currentMarkdown;
    }

    updateMarkmap(currentMarkdown);
}


function removeContextMenu() {
    const existingMenu = document.getElementById('node-context-menu');
    if (existingMenu) {
        existingMenu.remove();
    }
}

function createContextMenu(event, nodeData) {
    const { pageX, pageY } = event;

    const lines = currentMarkdown.split('\n');
    const lineIndex = nodeData.data?.payload?.lines?.[0];
    if (lineIndex === undefined || lines[lineIndex] === undefined) {
        console.error("Invalid node data for context menu:", nodeData);
        return;
    }
    const fullLine = lines[lineIndex];

    const menu = document.createElement('div');
    menu.id = 'node-context-menu';
    menu.className = 'context-menu';
    menu.addEventListener('contextmenu', e => e.preventDefault());

    const editItem = document.createElement('div');
    editItem.className = 'context-menu-item';
    editItem.innerHTML = T('editNodeTitle');
    editItem.onclick = (e) => {
        e.stopPropagation();
        removeContextMenu();
        
        const match = fullLine.match(/^(\s*(?:#+\s*|-\s*|\d+\.\s*))/);
        const prefix = match ? match[0] : '';
        const originalText = nodeData.data.content;

        openEditModal(originalText, lineIndex, prefix);
    };
    menu.appendChild(editItem);

    const deleteItem = document.createElement('div');
    deleteItem.className = 'context-menu-item';
    deleteItem.innerHTML = T('deleteNodeBtn');
    deleteItem.onclick = (e) => {
        e.stopPropagation();
        deleteNode(nodeData);
        removeContextMenu();
    };
    menu.appendChild(deleteItem);

    document.body.appendChild(menu);

    const menuWidth = menu.offsetWidth;
    const menuHeight = menu.offsetHeight;
    const { innerWidth, innerHeight } = window;
    
    let left = pageX;
    let top = pageY;

    if (pageX + menuWidth > innerWidth) {
        left = innerWidth - menuWidth - 5;
    }
    if (pageY + menuHeight > innerHeight) {
        top = innerHeight - menuHeight - 5;
    }

    menu.style.top = `${top}px`;
    menu.style.left = `${left}px`;
}

function setupNodeInteraction() {
    if (!mm || !d3) return;

    document.addEventListener('click', (e) => {
        if (!e.target.closest('.context-menu')) {
            removeContextMenu();
        }
    });

    mm.svg.on('contextmenu.editor', (event) => {
        event.preventDefault();
        event.stopPropagation();
        removeContextMenu();
        
        const node = event.target.closest('.markmap-node');
        if (!node) return;

        const d = d3.select(node).datum();
        if (!d?.data?.payload?.lines) return;
        
        createContextMenu(event, d);
    });
}


document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        if (!editNodeModal.classList.contains('hidden')) {
             e.preventDefault();
             closeEditModal();
        } else {
             removeContextMenu();
        }
        return;
    }

    if (!editNodeModal.classList.contains('hidden')) {
        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
             e.preventDefault();
             saveNodeEdit();
        }
        return;
    }

    if (e.key === 'F11') {
        e.preventDefault();
        toggleFullScreen();
    }

    const activeEl = document.activeElement;
    const isEditing = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA');

    if (!isEditing && aiResults.length > 1) {
        let newIndex;
        if (e.key === 'ArrowRight') {
            e.preventDefault();
            newIndex = (activeResultIndex + 1) % aiResults.length;
            switchToResult(newIndex);
        } else if (e.key === 'ArrowLeft') {
            e.preventDefault();
            newIndex = (activeResultIndex - 1 + aiResults.length) % aiResults.length;
            switchToResult(newIndex);
        }
    }

    if ((e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey) {
        if (e.key === 's') {
            e.preventDefault();
            exportPNG();
        }
        if (e.key === 'Enter') {
            if (document.activeElement === topicInput && topicInput.value.trim()){
                 e.preventDefault();
                 generateWithAI();
            }
        }
    }
});

document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
